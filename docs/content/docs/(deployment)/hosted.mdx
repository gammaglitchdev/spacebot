---
title: Hosted
description: One-click hosted Spacebot deployment on spacebot.sh.
---

# spacebot.sh — Hosted Deployment

One-click hosted Spacebot for people who don't want to self-host.

## What We're Building

A web app at spacebot.sh where a user signs up, connects their Discord/Slack/Telegram, configures their agent (identity, model preferences, API keys or pay-per-use), and gets a running Spacebot instance with zero infrastructure knowledge.

Each user gets an isolated Spacebot process with its own databases, identity, and messaging connections. Not multi-tenant — full isolation per user.

## Architecture

### Why Per-User Isolation

Spacebot is a stateful, long-running daemon. Each instance holds:

- Open websocket connections to Discord/Slack/Telegram
- SQLite, LanceDB, and redb databases on local disk
- In-memory state (active channels, branches, workers, cortex)
- Optional headless Chrome for browser workers

Multi-tenanting this would mean rewriting the core. The binary already handles multiple agents within one process, but sharing a process across users introduces security boundaries, resource contention, and failure blast radius problems that aren't worth solving. The simpler answer: one container per user, same binary they'd self-host.

### Fly Machines

Each user gets a Fly Machine (Firecracker microVM) with an attached Fly Volume for persistent storage.

**Why Fly over Kubernetes:**

- Fly's model is literally "one stateful process with a volume" — maps 1:1 to Spacebot
- No cluster management, no PVC provisioning delays, no control plane scaling concerns
- The Docker image is standard — migration to kube later is just a deployment target change

**Why not multi-tenant on fewer machines:**

- Spacebot holds open websocket connections per messaging platform — one user's Discord reconnect loop shouldn't affect another user
- SQLite doesn't do concurrent writers well across processes — you'd need to move to Postgres, which changes the entire data layer
- Browser workers spawn headless Chrome — untrusted code execution needs process-level isolation anyway
- Failure isolation: one user's OOM or panic kills only their instance

### Per-User App Model

Fly recommends one App per customer for isolation. Each user's app contains:

```
fly-app: spacebot-{user_id}
  machine: spacebot-{user_id}-main
    image: ghcr.io/spacedriveapp/spacebot:latest
    size: shared-cpu-1x, 512MB RAM
    volume: /data (10GB default, expandable)
    auto_stop: off (always-on)
```

The volume mounts at `/data`, which becomes the `SPACEBOT_DIR`. Contains everything:

```
/data/
├── config.toml          # generated from dashboard settings
├── agents/
│   └── main/
│       ├── workspace/   # identity files
│       ├── data/        # SQLite, LanceDB, redb
│       └── archives/
├── prompts/
└── logs/
```

### Always-On

Spacebot is an active daemon by design. The cortex ticks on an interval, cron jobs fire on schedules, and messaging adapters hold persistent websocket connections. Every hosted instance is always-on — there is no idle/suspend model.

## Control Plane

A separate service that manages the fleet. This is NOT Spacebot — it's a standard web app.

### Stack

- **Web framework** — Next.js or similar (dashboard + API)
- **Database** — Postgres (user accounts, billing state, machine metadata)
- **Auth** — OAuth (Discord, Google, GitHub) + email/password
- **Payments** — Stripe (subscriptions + metered billing for LLM usage)
- **Fly API client** — HTTP calls to `api.machines.dev` for machine lifecycle

### What It Does

1. **User signup** — create account, choose a plan
2. **Onboarding wizard** — connect messaging platforms, set identity, pick models
3. **Provision** — create Fly App + Machine + Volume, generate `config.toml`, start the machine
4. **Dashboard** — agent management, memory browser, conversation history, cron config
5. **Settings** — update identity files, model preferences, messaging connections
6. **Billing** — subscription tiers + optional pay-per-use LLM billing
7. **Monitoring** — machine health, restart on crash, usage metrics

### Provisioning Flow

```
User completes onboarding
    → Control plane creates Fly App (spacebot-{user_id})
    → Creates Volume (5GB, user's chosen region)
    → Creates Machine with:
        - Spacebot Docker image
        - Volume mounted at /data
        - Environment variables (API keys, config)
        - Auto-stop: suspend (or off for always-on tier)
    → Waits for machine to start
    → Writes config.toml to volume via init script
    → Machine starts Spacebot daemon
    → Messaging adapters connect
    → User gets a "your agent is live" confirmation
```

### Config Sync

When a user changes settings in the dashboard, the control plane needs to update the running Spacebot instance. Two approaches:

**Option A: Config file write + restart.** Control plane SSHs/execs into the machine, writes a new `config.toml`, and restarts the daemon. Simple but causes a brief interruption.

**Option B: Webhook API.** Spacebot exposes an HTTP endpoint (the webhook adapter) that accepts config updates. The control plane sends a PATCH to the running instance. Spacebot already supports hot-reload for config values, prompts, identity, and skills — this extends it to accept updates over HTTP.

Option B is better. The webhook adapter already exists in the architecture. Extend it with authenticated config endpoints.

### Dashboard Features

**Agent management:**

- Edit SOUL.md, IDENTITY.md, USER.md via a text editor in the browser
- Create/delete agents (multi-agent support)
- Configure model routing (which models for channels, workers, cortex)

**Memory browser:**

- Search memories by type, content, date
- View memory graph (associations, edges)
- Manual memory CRUD (create, edit, delete)
- Import memories from files (ingestion pipeline)

**Conversation history:**

- Browse past conversations across all channels
- View branch and worker activity per conversation
- Compaction history

**Cron jobs:**

- Create/edit/delete cron jobs
- View execution history and circuit breaker status
- Set active hours and delivery targets

**Monitoring:**

- Machine status (running, error)
- Resource usage (CPU, memory, disk)
- LLM usage (tokens consumed, cost estimate)
- Messaging adapter health

## Docker Image

Single Dockerfile, multi-stage build:

See the [Dockerfile](../Dockerfile) in the repo root. Two variants:

- `spacebot:slim` (~150MB) — minimal runtime, no browser
- `spacebot:full` (~800MB) — includes Chromium for browser workers

The `--foreground` flag is important — no daemonization inside a container. Logs go to stdout, container runtime handles lifecycle. See [docker.md](docker.md) for full details.

### Image Updates

When we push a new Spacebot version:

1. Build and push to `ghcr.io/spacedriveapp/spacebot:latest`
2. Control plane rolls out updates to all machines (Fly's machine update API swaps the image)
3. Machines restart with the new image, volume data persists
4. Rolling update — process a batch at a time, skip machines that are currently handling active conversations
